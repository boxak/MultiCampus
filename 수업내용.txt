(1) 크롬 브라우저 설치 : https://www.google.com/chrome
(2) Java SE(JDK) 설치 : http://java.sun.com/ -> https://www.oracle.com/technetwork/java/index.html
     설치후 환경변수 설정 : JAVA_HOME, PATH
                                  JAVA_HOME - C:\Program Files\Java\jdk1.8.0_231
                                  PATH - %JAVA_HOME%\bin
(3) Eclipse 설치 : http://www.eclipse.org/
                        C:\unico\eclipse-workspace
                        프로젝트라는 폴더를 생성해야 한다.
                        - Java Project   -  javaexam
                        - Dynamic Web Project
                        - Spring MVC Project
                                 :
                        
 맛보기용 자바 프로그램 : FirstApp

 [ 자바 구문 ]

 1. 데이터 타입: 2장
 2. 변수 활용:2장
 3. 연산자:3장
 4. 제어문:4장
 5. 배열: 5장 
 -------------- 기본 구문
 6. 클래스 정의와 객체 생성
 7. 상속, 다형성, 추상클래스, 인터페이스
 8. 예외처리

-------------------- OOP 구문 객체지향 구문

API - application programming interface
	자주 필요로하는 기능을 미리 만들어 놓은 프로그램
	클래스(Math, Date, Calendar, ...) - 패키지(java.io, java.net,java.sql, java.lang...) 패키지들
	IO 패키지 - 파일 입출력 패키지. 
	패키지 - 클래스 묶음. JAVA.LANG - OBJECT, STRING, STIRNGbUFFER 등등 클래스들.
	패키지화 학습 소스들을 패키지화 : DAY1, DAY2 ..... 클래스 묶어 놓고, 그룹화

LiteralTest

1.데이터 타입
	프로그램 - 데이타 처리를 위한 것 빠르고 정확하고
	자바로 처리할수 있는 데이타 종류들

	숫자데이터 - 정수/byte,short,int,long , 실수/float/double(소수점 붙어있는 수)
	1 1.0 '1' 완전히 각기 다른 일.
	정수/byte 1byte short 2byte int 4byte long 8byte  || 실수 / float 4 double 8
	왠만해서는 byte나 short 거의 안쓴다고 보면됌.

	논리데이터 - true, false
	문자데이터 - 문자의 코드값 처리 가능. 2 byte. '1' = 49(ascii) , '1' - 0031 , 'a' - 0061 '가' - AC00
	문자열데이터 - rorcpfh cnlrmq.
	
1 정수 1.0 실수 '1' 문자 "1" 문자열

리터럴(literal) : 프로그램 소스코드에서 사용되는 데이터값
	1, 1.0, '1', "1", "가나다", true, false 이 모두다 리터럴 정수, 실수, 문자, 문자열 리터럴, 

변수 : 데이터 값을 저장하는 메모리의 방
	데이터값을 저장하기 위해 메모리의 일정 공간에 붙여진 이름.
 	저장된 데이터 값을 계속해서 변경 가능
	필요시 생성해서 사용한다

변수 선언 int(타입, variable type) num(메모리방 이름, variable name, address)

변수명 명명법 소문자로 시작, 명사, 숫자로 시작 불가, 중간에는 가능, _, $ 는 괜춘.
클래스는 대문자로

자바 주요 연산자
	- 기능
	산술연산자, 비교연산자, 논리연산자, 조건연산자, 대입연산자

	- 사용되는항 (피연산자, 연산에 사용되는 데이터) 의 갯수
	단항 연산자 : ++num(num = num+1) R 지원안함.
	이항연산자 : 항1 연산자 항2
	삼항 연산자: 항1 ? 항2 : 항3

	. 
	++, --, +,  -, *, /, !, ~, (타입명)
 	*, /, %
             +, -
	==, !=, >, <, >=, <=, instanceof
	>>,>>>,<<
	&, |, ^
	&& 
             ||
	항1 ? 항2 : 항3 (삼항)
	=, +=, -=, *=, /=
	

 	연산자 피연산자(항)

             ++su, --su, -su, !true
           
             ++su, su++

  l-value : 방 : 변수
  r-value : 값 : 식(변수, 리터럴, 연산식, 리턴값이 있는 메서드의 호출식)

  = 연산을 처리할 때
  l-value의 타입과 r-value의 타입은 동일해야 한다.
  그런데 만일 다른 타입이 사용되면 r-value의 값이 손실되지 않는 범위에서
  l-value의 타입으로 자동 변환한다.

         int = char
         (4)   (2)
         int = double
         (4)   (8)

         byte < short < int < long < float < double
         (1)      (2)      (4)   (8)     (4)      (8)
         char < int < long < float < double
         (2)      (4)   (8)     (4)      (8)

         boolean

         short = (short)char
         char = (char)short
         char = (char)byte

  [ 제어문 ]

  정의된 수행 문장들을 한번씩 순차적으로 수행하면서 진행하는 것이 기본이지만
  조건에 따라 수행 문장들을 선택하여 수행거나 반복해서 여러번 수행도록 하고자 할 때
  제어문을 사용한다.

  - 선택(조건)제어문 - if(else), switch
  - 반복제어문 - for, while, do ~ while
  - 분기제어문 - break, continue

  if(조건식)
     수행문장;

  if(조건식) {
     수행문장1;
     수행문장2;
  }

  if(조건식) {
     수행문장1;
     수행문장2;
  } else {
     수행문장3;
     수행문장4;
  }

  if(조건식1)
     수행문장1;
  else if(조건식2)
     수행문장2;
  else if(조건식3)
     수행문장3;
         :
  else
     수행문장n;

   switch(식) {
      case 비교값1 : 수행문장1;
                          수행문장2;
      case 비교값2 : 수행문장3;
                          수행문장4;
      case 비교값3 : 수행문장5;
                          수행문장6;
      case 비교값4 : 수행문장7;
                          수행문장8;
      default : 수행문장9;
   }

    switch(식) {
      case 비교값1 : 수행문장1;
                          수행문장2;
                          break;
      case 비교값2 : 수행문장3;
                          수행문장4;
                          break;
      case 비교값3 : 수행문장5;
                          수행문장6;
      case 비교값4 : 수행문장7;
                          수행문장8;
		break;
      default : 수행문장9;                    
   }
  
   식 : int(byte,short,char), String

    




   [ 반복구문 ]
   for   	: 미리 반복횟수를 할고 있거나 어떠한 값의 변화를 주면서 반복하려는 경우
   while	: 조건이 만족되는 동안 반복하려는 경우

   for(초기식;조건식;증감식)
       반복문장

   for(;조건식;)
       반복문장;

   while(조건식)
       반복문장


   for(변수의선언 및 초기화;반복횟수를 결정할 조건식;변수의 값을 변화시키는식)

   for(;;)    ---> 무한루프

   for(int i=1; i <= 10; i++)
         반복문장

   for(int i=1; i <= 10; i+=2)
         반복문장


   for(int num=1; num <= 9; ++num)
	System.out.print(5*num + "    ")

   for(int n=5; n > 0; n--)
	System.out.println(n)

   for(int n=5; n > 0; n++)
	System.out.println(n)


   l-value = r-value
   변수        식

   double    int
   long       char
   int         (int)double   
   char       (char)int

   - 자동 형 변환
     (1) 정수에서 실수
     (2) 사이즈 적은타입에서 큰타입

   v1 + v2

   int   int   --> int
   long long --> long
   float float --> float
   int   double --> double
   int   char  --> int
   int   long  --> long
   long  float  --> float

   char  char  --> int

   - 중첩된 for 문 : 구구단

     						
   for : 횟수에 반복, 값의 변화에 따른 반복
   while : 조건에 따른 반복	

   for(초기식;조건식;증감식)
         반복문장;	

   초기식;
   while(조건식) {
         반복문장;			      
         증감식;
   }

   JAVA, [SQL], JavaScript, R, Scalar, (PYTHON)

   [ 자바의 산술 이항 연산의 특징 ] - 교재 92 페이지

   (1) int 타입보다 작은 타입들(byte, short, char)은 int 타입으로 변환하여 연산
   (2) 두 항의 타입이 다를 때 하나로 일치해서 연산(표현 범위가 적은 타입에서 큰타입으로)

        표현 범위의 관계 : int < long < float < double





  for( 변수선언  : 배열)





  [ 배열 : array ]
  - 동일한 타입의 데이터들의 집합
  - 배열을 만드는 방법
  - 배열을 사용하는 방법
  - 여러 개의 데이터들을 프로그램에서 다뤄야 할 때 변수를 여러개 선언하여 사용하는 것은
     비효율적이다.(코딩, 수행)

  - 배열을 만드는 방법
    - 배열로 구성하려는 데이터들의 타입
    - 배열로 구성하려는 데이터들의 최대 갯수

	new 데이터타입[크기]
  
  	new int[10]      	----- 0
	new char[26]	----- '\u0000'
	new double[5]	----- 0.0
	new long[1]  	----- 0L
             new boolean[10] 	----- false


	{ 값1, 값2, 값3, ... }  --> 배열 생성과 배열변수 선언을 동시에 할 때

	{ 10, 20, 30 }, {4,1,5,7,8,1,3}, {'a', 'b', 'c'}, {true}

   - 배열을 사용하는 방법
     배열을 사용하 위해서는 배열을 만든다음 변수에 담는다.
     배열변수가 필요하다.

     타입[ ]  변수명;, 타입  변수명[ ];

	int a1[];, int[] a2; char[] a3; boolean a4[];

	int a1[] = new int[10];
             int a2[] = {10,20,30};

	a1[0], a1[1], a1[2] .... a1[9]

	배열변수명[인덱스] // 인덱스는 0 부터 지정
            
             배열을 구성하는 데이터들 : 엘리먼트(element), 요소, 원소
             배열변수.length : 배열변수에 대입된 배열의 요소갯수

	System.out.println(a1[0]);
	System.out.println(a1[1]);
	System.out.println(a1[2]);
                            :
	System.out.println(a1[9]);

             a1[0] = 1000;
	a1[1] = 999;
	a1[9] += 10;

	for(int i=0; i < a1.length; i++)
	   System.out.println(a1[i]);
 
  System.out.println(), System.out.print()
  (1) 출력 데이터를 한 개만
  (2) 출력데이터 여러개일 때는 + 연산자로 결합하여 한 개로 전달해야
  (3) 출력하려는 데이터의 타입에 따라 출력 형식이 정해진다.
       int -> 10진수 숫자
       char -> 문자
       double -> 소수점 이하의 자리수를 설정불가


  Java 5(JDK 1.5)  - System.out.printf()
      		  System.out.printf("출력하려는포맷문자열")
		System.out.printf("가나다")
		System.out.printf("가나다\n")
		System.out.printf("가나다%n")
		System.out.printf("가나다")
		System.out.printf("가나%d다", sum)
		System.out.printf("가나%.2f다", avg)
		System.out.printf("가%d나%.3f다", sum, avg)
		System.out.printf("가%d나%.3f다", 100, 99.56789)
		System.out.printf("%s%s%s", "java", "c#", "c++")
		System.out.printf("%s %s %s", "java", "c#", "c++")
		System.out.printf("%s  %s  %s", "java", "c#", "c++")
		System.out.printf("%10s%10s%10s", "java", "c#", "c++")

   Sun Microsystems  ---> 2010 --> Oracle

   JDK 1.0 -> JDK 1.1 -> JDK 1.2 -> JDK 1.3 -> JDK 1.4 -> JDK 1.5(Java 5)

                                                                         C#
                                                                        (MS)
  [ 메서드 ]   

  -수행 코드(수행 명령, 수행 문장)를 정의하는 단위 : 기능
  -main 도 메서드이다.
  -클래스 안에 정의된다. 
  -하나의 클래스 안에는 0개 이상의 메서드가 정의될 수 있다.
  -메서드를 생성하는 방법
  -메서드를 사용하는 방법 - 호출 

  [ 메서드를 생성하는 방법 ]

  - 메서드명 : (1) 소문자로 시작하고 새로운 워드 등장시 첫 글자만 대문자로
	     (2) 식별자(명명) 규칙 적용
	     (3) 동사로 시작
  - 메서드 호출시 전달받을 데이터의 유무를 결정
     유 : 몇 개, 어떤 타입 -------> 매개 변수 선언
  - 호출된 후에 호출한 곳으로 값을 줄 것인지의 여부를 결정 -- 리턴값
     return 이라는 구문을 사용한다.

        [제어자] 리턴값의타입   메서드명([매개변수 선언]) {
	지연변수 선언;
	수행 문장.....

	[return 리턴값; ]
        }


   [ 메서드를 사용하는 방법 - 호출 ]

   (1) 기능
   (2) 헤더를 보고
        - 메서드명
        - 호출시 전달할 데이터(아규먼트)의 유무 
        - 리턴값의 유무에 따라서 리턴값을 사용

            변수 = 식

	result = System.out.println();
	rand = Math.random();


     - 배열 타입의 매개변수를 선언하여 메서드 호출시 배열을 아규먼트로 전달받으면
        전달받는 데이터의 갯수를 제한하지 않게 된다.

     - Java 5(JDK 1.5)
       가변형 아규먼트 구문이 추가된다.

       리턴타입 메서드명(int... p) { p를 배열로 사용한다.  }

       메서드명(1,2,3), 메서드명(1,2,3,4,5), 메서드명()

       new int[0]

    프로그램 아규먼트(명령행 데이터)
    프로그램을 수행 시작시키면서 최초에 한번만 전달되는 데이터들
    main(String[] args)
    (Intger.parsInt(), Double.parseDouble() 를 이용해서 숫자로 변환하여 사용한다.)













  [ 생성자 메서드:constructor ]

  - 클래스를 객체 생성할 때 호출되는 메서드 이다.
        new 클래스명()
              -------- 생성자 메서드
  - 모든 클래스는 1개 이상의 생성자 메서드를 가지고 있어야 한다.
  - 클래스의 소스에 생성자 메서드가 정의되어 있지 않으면 컴파일러가 생성자를
     만들어 준다. --> 디폴트 생성자
  - 생성자 메서드 정의 방법
    (1) 메서드명은 클래스명과 동일해야 한다.
    (2) 매개변수는 선택적이다.(오버로딩 가능하다.)
    (3) 리턴값의 타입은 생략한다.
    (4) 객체 생성시 수행해야 하는 기능 또는 객체 생성시 데이터를 전달받아서
          멤버변수들의 값을 초기화 하는 기능

  C:\unico\eclipse-workspace\javaexam\bin

      this : 자신의 객체의 참조값을 의미하는 리터럴
              this.xxxx 나의 멤버 xxxx

      this() : 생성자 메서드내에서만 호출 가능
                 생성자 메서드의 첫 행에서만 호출 가능
                 동일한 클래스내에 있는 다른 생성자를 호출

     int[] ary = new int[5];

     Product[] p = new Product[5];

      
  [ 방법 1 ]
  import day6.MethodLab3;
  class 클래스명 {
           main() 메서드 헤더 {
	int month = MethodLab3.getRandom(12);

           }
  }

  [ 방법 2 ]
  class 클래스명 {
           main() 메서드 헤더 {
	int month = day6.MethodLab3.getRandom(12);

           }
  }
  [ static(정적, 고정, 공유) ]
  - 제어자
  - 멤버변수와 메서드 앞에 지정 가능하다.
  - static 을 설정한 멤버변수와 메서드는 객체생성을 하지 않아도 자동으로 
     메모리 영역을 할당하 하거나 호출 가능 가능한 상태가 된다.
  - 다른 클래스에서 또 다른 클래스의 static 타입의 멤버를 사용할 때는
    클래스명.멤버명 으로 사용한다.
  - 클래스에 정의되는 멤버들중 어떤 멤버에 static 부여 하는가?
     변수(멤버)
     메서드
  
   -verbose:class : JVM 옵션
    클래스 로딩 정보를 보여주면서 자바 프로그램을 수행시켜라!!

   [ 블록 스코프 ]

   메서드 헤더 {
      int a;
      //int b;
      if( .... ) {
	int b;
      	 :
      }

      int c;
      int b;


   }

   [ 표준입력 ]

   - 프로그램이 수행하는 동안 필요로 하는 데이터를 시스템의 표준 입력 장치로 부터 
      받아 오는 것 
      표준 입력 장치 - 키보드
   - Java에서는 표준 입력을 어떻게 처리 하느냐... --> System.in
             
	System.in.read()
         
     Java 5(JDK 1.5)
     java.util.Scanner 클래스를 제공하여 좀더 편하게 데이터 입력받을 수 있게
     API를 추가했다.

	Scanner scan = new Scanner(System.in);

	scan.next()
	scan.nextLine()
	scan.nextInt()
	scan.nextDouble()
		:


    
  
    cc\n





   Scanner - next(), nextInt(), nextDouble(), nextLine()

      readLine() : String


   aaa  bbb      ccc    ddd\n


   aaa\n  
   bbb\n      
   ccc\n    
   ddd\n
   [ 상속 ]
   - 자바의 모든 객체들은 상속이라는 객체지향언어의 특징을 지원한다.
   - 자바에서 생상되는 모든 객체들은 기본적으로 java.lang.Object 이라는 객체를
      상속하게 된다.
   - 클래스 헤더에 exetdns 라는 절을 사용하는 부모 클래스를 설정하는데
      하나의 부모 클래스만 설정 가능하다.
   - 조상부터 물려받은 메서드들은 필요에 따라 대체할 수 있다.- 메서드 오버라이딩이라 한다.
   - 어떤 클래스든 객체를 생성하면 해당 클래스만 메모리 할당하는 것이 아니라
      조상 클래스들도 메모리 할당한다.
   - 자손클래스의 객체 생성시 생성자 메서드가 호출되면 바로 조상 클래스의 생성자도 호출
     된다. 내부적으로는 아규먼트 없는 생성자가 호출되는데 다른 생성자를 호출하려는 경우
     super() 라는 메서드를 사용한다.
   - 객체를 참조하는 용도 : this, super
   - 객체를 초기화하는 용도로 사용되는 생성자 메서드 호출 : this(), super() 
   - this(), super() : 생성자 안에서만 호출 가능
   - this, super : 객체 생성 시점에 초기화 된다. static 메서드에서는 사용 불가하다.
                       non-static 메서드와 생성자 메서드에서만 사용 가능하다.

   [ 제어자 : modifier(수정자, 한정자, 제어자) ]

   접근 제어자 : public, protected, (default), private
   활용 제어자 : final, static, abstract, transient, synchronized, .....
                    -----
   제어자란 클래스, 메서드, 변수앞에 설정되어 접근 가능 여부와 사용 방식을 제어하는 구문

               [제어자] class 클래스명 extends 부모클래스명 {
		[제어자]멤버변수 선언

		[제어자]생성자 메서드 정의

		[제어자]메서드 정의
               }   

	 public, final, abstract class 클래스명 extends 부모클래스명 {
		모든접근제어자, final, static 멤버변수 선언

		모든접근제어자 생성자 메서드 정의

		모든접근제어자, static, final, abstract 메서드 정의
               }          

	- 클래스에는 접근제어자를 두 가지만 설정 가능 : public, (default)
                   public 클래스 : 누구나
                   (default) 클래스 : 동일 패키지내의 클래스 
             - final - 변경할 수 없는, 마지막의
                abstract - 반드시 변경해야 하는, 마지막 아닌, 미완성의
                final 클래스 : 상속 불가, 객체 생성 가능
                abstract 클래스 : 객체 생성 불가, 상속만 가능    
           
             -   public  -  누구나
	    protected - 동일패키지 이거나 자손이면 접근 가능
	     (default) - 동일 패키지	          	 
	    private - 자손이든 객체 생성한 클래스든 접근 불가
                               멤버가 정의된 클래스 내에서만 사용 가능


                 +  : public
                 #  : protected
	    (), ~ : (default)
                 - : private

            - static, final을 함께 지정하여 상수를 만든다.

	 public class Math {
		public final static double PI = 3.14159;

              }

	Math.PI

	Integer.MAX_VALUE

	- 메서드에
	   final : 자손에 의해 오버라이딩이 불가능한 메서드를 정의
	   abstract : 자손에 의해 반드시 오버라이딩 해야 하는 메서드를 정의
		     메서드의 헤더만 정의되고 바디가 없는 메서드






     ==
   숫자나 문자는 등가 연산자로 값이 동일한지 비교 가능하지만
   문자열은 등가 연산자로 비교할 수 있는 경우도 있지만 일적으로
   API를 사용해야 한다.

   equals() 메서드를 사용해야 한다.
   String 클래스가 제공

   자바는 문자열 리터럴은 String 객체로 취급된다.

   'y' : char 타입, 기본형
   "y" : String 타입, 객체형(참조형)

   "y".equals("...")



  다형성, abstract 클래스, 인터페이스, 예외처리
  [ 다형성 ]

  참조형 변수(클래스 타입)는 타입에 지정된 클래스 객체뿐만 아니라 타입에 지정된 클래스의
  자손의 객체도 참조할 수 있다.

	A obj;
	obj = new A();
	obj = new B();
	obj = new C();
  

         void 메서드(A obj ) {

         }


       	Objcet o = new Date();
     	Date d = new Date();
	Member m = new Date(); (X)








    강사컴 IP 주소 : 70.12.115.160
    강사컴 접근 방법 : 시작메뉴에서 오른쪽 버튼 -> 실행 메뉴 -> \\70.12.115.160

    학습 환경 준비 : 
    (1) 크롬 브라우저 설치
    (2) JDK 설치
    (3) 환경 변수 세팅 : JAVA_HOME, Path 환경 변수
         (C:\Program Files\Java\jdk1.8.0_231, %JAVA_HOME%\bin)
         윈도우즈 탐색기에서 내PC에 마우스 올리고 오른쪽 버튼 클릭후 속성 메뉴 선택 
         시스템 정보 창이 출력되면 왼쪽에 '고급 시스템 설정' 메뉴 선택
         시스템 속성창이 출력되면 환경변수 메뉴를 선택한 후에 
         환경 변수를 설정한다.
         설정 후에는 cmd 창을 기동시켜서 javac 라는 명령을 수행시켜 제대로 설정되었지 확인
    (4) 이클립스 설치
         적당한 디렉토리에 이클립스 압축 파일을 푼다.
         이클립스를 기동 시킨다.(워킹 디렉토리는 본인이 원하는 곳으로)

    (5) 백업한 javaexam 폴더는 c:\Temp에 저장해 놓는다.
    
    ---> 이후 과정은 모두 함께 진행할 예정임...
         
   [ 인터페이스 ]

   - 클래스, final 클래스, abstract 클래스
   - 인터페이스는 모든 메서드가 abstract 메서드인 클래스를 의미한다.
   - 자바는 단일 상속을 지원하는 OOP 언어이다.
      모든 메서드가 abstract인 클래스를 상속한 경우 다른 클래스는 상속 불가
      ----> 인터페이스는 추가 상속이 가능은 특별한 형태의 클래스이다.
   - 인터페이스는 abstract 클래스와 비슷한 자바 프로그램의 구조로서
      객체 생성은 불가하고 상속으로만 사용이 가능하다.
   - 인터페이스 생성 방법

	interface 인터페이스이름 {
		상수
		abstract 메서드
             }

   - 인터페이스 사용 방법 : 상속

	interface 인터페이스이름 extends 부모인터페이스이름 {
		:
	}

	class 클래스명 extends 부모클래스명 implements 부모인터페이스이름 {


	}
	









    JDK 1.0  JDK 1.1
      8개        23개

    java.nnn    - 기본
	java.lang, java.util, java.io, java.net, java.sql.....	   
    javax.nnn  - 확장
             javax.sql, javax.nio....

    -------> 자바언어에서만 지원하는 API
    org.nnn     -
    -------> 자바에서만 지원하지 않고 다른 프로그래밍 언어에서도 지원되는 API로
                 어떤 표준화 위원회나 조직에서 정한 API를 자바에도 지원하기 
                 위해 만든 API
    
  [ 오류 처리 ]
   - 컴파일 오류 : 구문오류, API 사용 오류
   - 실행 오류 : 에러 - JVM 영역에서 발생하는 오류로서 치명적이라
                             JVM이 프로그램 실행을 중단시키고 callstack 정보를 화면에 출력한다.
	                미리 예측하고 대비하는 코드를 작성 불가
	       예외 - 자바 프로그램 영역에서 발생하는 실행 오류로 다소 가벼운 잘못된 상황
                             런타임 예외 - 발생 원인이 프로그램 코드 - 버그 - 예외 처리 선택
		   일반 예외 - 발생 원인이 외부적인 요인이다. - 예외 처리 필수 
   - 예외 처리 방법
     1. 적극적인 예외 처리

	try {
	      예외가 발생할 수도 있는 코드

   	} catch (처리해야하는 예외 클래스의 변수선언) {
                   처리 코드
	} finally {
	      예외 발생 여부와 관계없이 마지막에 수행을 보장하는 코드
             }

     2. 소극적인 예외 처리
	
	메서드 헤더에 'throws 처리해야하는 예외 클래스' 절을 추가

   - 예외 발생

           throw 발생시키고자하는예외클래스의객체

	throw new IOException(["예외메시지"])

           예외를 발생시키는 코드를 가지고 있는 메서드는 헤더 throws 절을 사용해서
           이 메서드는 호출시 예외가 발생할 수도 있다는 것을 알려야 한다.


















  1시 20분부터 Java API 활용 공부합니다.







  java.lang - Object, Math, Integer, String, StringBuffer, Character ...

	String : 문자열 처리와 관련된 메서드들을 가지고 있다.
                        String 객체가 생성된 이후 초기화된 문자열 내용은 변경 불가하다.	 
                        읽기 용도로만 사용 가능하다.

	           "abc" + "가나다"  -> "abc가나다"

	           "a" + "b" + "c" + "d"

	StringBuffer : 문자열 편집하는 용도

		StringBuffer sb = new StringBuffer();
		sb.append("a");
		sb.append("b");
		sb.append("c");
		sb.append("d");

	equals() : Object 클래스 : == 연산과 동일

	Book b1 = new Book("짱구", "xxx", 10000);
	Book b2 = new Book("짱구", "xxx", 10000);
	Book b3 = b2;

	b1 == b2 ? false
             b3 == b2 ? true
	b1.equals(b2) ? false
	b3.equals(b2) ? true
























   























   









		




