### [상속]

-아무것도 명시를 안해줘도 기본적으로 java.lang.Object 클래스를 부모로 해서 멤버들을 상속받는다.

> ```java
> package day8;
> 
> class Parent{ //아무것도 없는 것같지만 java.lang.Object 라는 클래스를 상속받는다. 
> 	int x=1,y=2;
> 	public String toString() {
> 		return "Parent 클래스의 객체입니당";
> 	}
> }
> 
> class Child extends Parent{ //Parent가 Child의 부모 클래스가 됨.
> 	int x=10;
> 	void printInfo() {
> 		int x=100; //멤버 변수와 지역 변수 이름이 같으면 지역 변수를 사용.
> 		System.out.println(x); //->100
> 		System.out.println(this.x); //->10
> 		System.out.println(super.x); //->1 무조건 조상(가장 가까운 부모)으로 올라가서 찾음
> 		System.out.println(y); //->2 지역변수, 현재 클래스에 없으면 조상에 간다.
> 		System.out.println(this.y); //->2 현재 클래스에 없으면 조상에 간다.
> 		System.out.println(super.y); //->2 무조건 조상으로 올라간다.
> 		System.out.println(z); //-> 조상에게도 없으므로 에러
> 	}
> 	public String toString() {
> 		return "Child 클래스의 객체입니당";
> 	}
> }
> 
> public class ParentChildTest {
> 
> 	public static void main(String[] args) {
> 		Parent p=new Parent(); // 디폴트 생성자
> 		System.out.println(p.toString()); //객체의 정보를 하나의 문자열로 리턴하는 메서드
>         System.out.println(p);
>         System.out.println("출력1"+p);
> 		Card c=new Card();
> 		System.out.println(c.toString());
>         System.out.println("출력2"+c);
> 		java.util.Date d=new java.util.Date();
> 		System.out.println(d.toString()); //toString()을 Date에 맞게 오버라이딩을 한 경우-> 메서드 오버라이딩
> 		System.out.println("출력3"+d);//->자동으로 toString()호출
>         Child ch=new Child();
> 		System.out.println("출력3 "+ch);
> 	}
> 
> }
> ```

-해당 클래스가 가진 멤버 뿐만 아니라 클래스의 부모 클래스들의 멤버도 호출할 수 있다.

-오버라이딩의 조건 : 클래스는 다르되 헤더가 전부 똑같아야 함.

-자바의 모든 객체들은 상속이라는 객체지향언어의 특징을 지원한다.

-자바에서 생성되는 모든 객체들은 기본적으로 java,lang.Object라는 객체를 상속하게 된다. -> 다형성을 활용할 수 있게 해준다.

-클래스 헤더에 extends라는 절을 사용하는 부모 클래스를 설정하는데 하나의 부모 클래스만 설정 가능하다.(단일 상속)

#### 조상부터 물려받은 메서드들은 필요에 따라 대체할 수 있다 -> 메서드 오버라이딩이라 한다.

-어떤 클래스든 객체를  생성하면 해당 클래스만 메모리 할당하는 것이 아니라 조상 클래스들도 메모리 할당한다. 

-this, super 등은 해당 클래스에서 유효한 것, ex) main 클래스에서 super or this 등을 사용하면 ㄴㄴ.

-모든 생성자 메서드들은 호출되자마자 조상 클래스의 생성자부터 호출하면서 내려온다.->상속을 위해서는 argument를 안받는 생성자를 만들어두는게 좋다. argument 안받는 조상 생성자를 호출하기 때문임. argument 안받는 생성자가 없으면 자식 클래스에서 직접 호출해야 함. 

#### -> super()를 사용해서 호출할 수 있다!(시험)

##### -생성자에 super()가 없으면 컴파이얼러가 기본적으로 super()를 넣어준다.(argument없이)

##### -this 메서드가 호출되는 애들도 super()를 안넣어준다.

-자손 클래스의 객체 생성시에는 생성자 메서드가 호출되면 바로 조상 클래스의 생성자도 호출된다.

내부적으로는 argument 없는 생성자가 호출되는데 다른 생성자를 호출하려는 경우 super()라는 메서드를 사용한다.

-객체를 참조하는 용도 : this, super

-객체를 초기화하는 용도로 사용되는 생성자 메서드 호출에 : this(), super()

-제대로 오버라이딩을 하려면 리턴값의 유형도 같아야 한다.

#### -this(),super() : 생성자 안에서만 호출 가능, 생성자 메서드의 첫 행에서만 사용가능 두개를 동시에 못쓴다

-this, super : 객체 참조 리터럴, 객체 생성 시점에 초기화 된다. static 메서드에서는 사용 불가하다.

non-static 메서드와 생성자 메서드에서만 사용가능하다.

-부모 클래스를 손댈 것이 아니라 자식 클래스를 부모에 맞추는 것이 좋다., 제어자의 범위를 자손에서 더 좁게 해줄 수 없다. 부모에서 public인 메소드는 자식에서 public으로 해야 오버라이딩된다.

더 넓어지는 것은 허용.(다형성 구문 때문임)

-자손은 조상의 모든 멤버를 상속받으므로 자손의 멤버 개수는 조상보다 적을 수 없다.

-child1과 child2의 부모가 같아도 child1과 2는 아무런 관계가 없다.

-is a가 어울리면 상속 ,has a가 어울리면 포함

-비중이 높은 클래스 하나만 상속, 나머지는 포함관계로 처리

